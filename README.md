# Lattice FFT Playground

An interactive environment for studying how real-space lattice order maps into reciprocal-space scattering intensities through the Fast Fourier Transform (FFT). The repository combines pedagogical notebooks with a reusable Python package that exposes the full simulation pipeline for research, teaching, and prototyping.

* **`FFT and lattice.ipynb`** – the original exploratory notebook that retains inline explanations, derivations, and widgets.
* **`lattice_fft_demo.ipynb`** – a concise demonstration of the packaged API in a clean environment.

## 1. Theoretical background

### 1.1 Real-space lattice model

We model a two-dimensional Bravais lattice generated by primitive vectors \(\mathbf{a}_1\) and \(\mathbf{a}_2\). The lattice points are positioned at

\[
\mathbf{R}_{mn} = m\,\mathbf{a}_1 + n\,\mathbf{a}_2, \qquad m,n \in \mathbb{Z}.
\]

To approximate the projected potential of atomic columns, each site contributes a normalized Gaussian of width \(\sigma\) (in pixels) centred at \(\mathbf{R}_{mn}\):

\[
I(\mathbf{r}) = \sum_{m,n} A\,\exp\left[-\frac{\lVert \mathbf{r} - \mathbf{R}_{mn} \rVert^2}{2\sigma^2}\right],
\]

where \(A\) controls the integrated intensity. Thermal vibrations are introduced via an isotropic Debye–Waller factor by sampling random displacements \(\Delta \mathbf{u}_{mn} \sim \mathcal{N}(0, \sigma_{\mathrm{jitter}}^2 \mathbf{I})\).

### 1.2 Reciprocal lattice and Fourier amplitudes

The reciprocal basis vectors \(\mathbf{b}_i\) satisfy \(\mathbf{a}_i \cdot \mathbf{b}_j = 2\pi \delta_{ij}\). Consequently, the reciprocal lattice vectors are

\[
\mathbf{G}_{hk} = h\,\mathbf{b}_1 + k\,\mathbf{b}_2, \qquad h,k \in \mathbb{Z}.
\]

For an ideal lattice of identical scatterers the kinematic structure factor is

\[
S(\mathbf{k}) = f(\mathbf{k}) \sum_{m,n} \exp\bigl(-i \mathbf{k} \cdot \mathbf{R}_{mn}\bigr),
\]

where \(f(\mathbf{k})\) is the atomic form factor. With Gaussian scatterers of width \(\sigma\), the envelope becomes

\[
f(\mathbf{k}) = A\,\exp\left(-\tfrac{1}{2}\sigma^2 \lVert \mathbf{k} \rVert^2\right).
\]

The discrete simulation grid imposes a sample spacing \(\Delta x\), yielding reciprocal-space pixel spacing \(\Delta k = \tfrac{2\pi}{N\,\Delta x}\) for an \(N \times N\) image.

### 1.3 Discrete Fourier Transform (DFT)

The FFT implementation computes the 2D DFT

\[
F(u,v) = \sum_{x=0}^{N_x-1} \sum_{y=0}^{N_y-1} I(x,y)\,\exp\left[-2\pi i\left(\frac{ux}{N_x} + \frac{vy}{N_y}\right)\right],
\]

whose magnitude \(|F(u,v)|\) reveals Bragg reflections at indices corresponding to \(\mathbf{G}_{hk}\). Logarithmic scaling emphasises both sharp Bragg peaks and diffuse intensity. Row-shear defects and stochastic vacancies are incorporated by perturbing \(\mathbf{R}_{mn}\), which broadens peaks and redistributes spectral weight into continuous streaks.

### 1.4 Disorder models

* **Row-shift disorder**: a fraction \(p_{\mathrm{shift}}\) of lattice rows receive a random offset \(\delta x \sim \mathcal{U}(-\Delta, \Delta)\), introducing phase slips that smear the corresponding reciprocal streaks.
* **Vacancies**: a Bernoulli process of probability \(p_{\mathrm{vac}}\) suppresses selected sites, reducing Bragg intensity while creating diffuse background.
* **Jitter**: the Debye–Waller displacement variance \(\langle u^2 \rangle = 2\sigma_{\mathrm{jitter}}^2\) attenuates peaks by a factor \(\exp[-\tfrac{1}{2}\langle u^2 \rangle \lVert \mathbf{k} \rVert^2]\).

These models follow the statistical treatments in solid-state diffraction texts [1,2].

## 2. Package architecture

```
.
├── lattice_fft/
│   ├── __init__.py           # Public API surface
│   ├── config.py             # Dataclasses describing lattice, defect, and jitter parameters
│   ├── lattices.py           # Basis-specific coordinate generation utilities
│   ├── plotting.py           # Matplotlib helpers for reciprocal/real-space figures
│   └── simulation.py         # Lattice synthesis, defect models, FFT computation
├── FFT and lattice.ipynb     # Legacy pedagogical notebook (unchanged)
├── lattice_fft_demo.ipynb    # Clean API demonstration
├── README.md                 # This document
└── pyproject.toml            # Optional packaging metadata
```

The `lattice_fft` package factors the simulation pipeline into testable components. Dataclasses in `config.py` capture physical parameters (including atomic amplitude and validation logic), `lattices.py` provides reusable routines for generating square and hexagonal Bravais lattices, `simulation.py` converts those parameters into rendered lattices and their FFTs, and `plotting.py` provides publication-ready figures.

## 3. Installation and environment setup

1. **Create and activate a virtual environment**
   ```bash
   python -m venv .venv
   source .venv/bin/activate  # On Windows use .venv\Scripts\activate
   python -m pip install --upgrade pip
   ```

2. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   # or install manually
   pip install numpy matplotlib
   ```

3. **Install the package in editable mode**
   ```bash
   pip install -e .
   ```

4. **Open the demonstration notebook**
   ```bash
   jupyter notebook lattice_fft_demo.ipynb
   ```

## 4. Programmatic usage

```python
from lattice_fft import (
    LatticeParameters,
    DefectParameters,
    JitterParameters,
    simulate_lattice,
    plot_real_and_fft,
)

params = LatticeParameters(
    ny=512,
    nx=512,
    px_size_angstrom=0.5,
    lattice_constant_angstrom=2.5,
    atom_sigma_angstrom=0.9,
    atom_amplitude=1.5,
)
defects = DefectParameters(defect_fraction=0.1, max_row_shift_px=3.0, remove_fraction=0.05)
jitter = JitterParameters(sigma_px=0.8)

result = simulate_lattice(
    params,
    basis="square",
    defect_params=defects,
    jitter=jitter,
)

fig = plot_real_and_fft(
    result.image,
    result.fft_log_magnitude,
    kx=result.kx,
    ky=result.ky,
    title_suffix="Square lattice with defects",
)
fig.tight_layout()
fig.show()
```

### Core abstractions

* **`LatticeParameters`** – lattice size, sampling pitch, lattice constant, Gaussian width, and amplitude with convenient unit conversions and validation.
* **`DefectParameters`** – stochastic model for row shifts, vacancies, and disorder fractions with physical bounds enforcement.
* **`JitterParameters`** – Debye–Waller-inspired Gaussian displacements with positivity checks.
* **`generate_lattice_positions` / `generate_lattice`** – deterministic lattice coordinate factories for square and hexagonal bases.
* **`compute_fft` / `compute_fft_magnitude`** – convenience wrappers that return complex spectra alongside physically meaningful reciprocal axes.
* **`simulate_lattice`** – generates lattice coordinates, applies disorder, renders intensities, performs FFT, and returns a `SimulationResult` container with pristine/defected coordinates, complex spectra, and both linear/log magnitudes.
* **`plot_real_and_fft`** – produces a paired Matplotlib figure for real-space and log-magnitude reciprocal space with labelled axes and optional automatic log scaling.

Auxiliary helpers such as `generate_lattice_positions`, `render_lattice_image`, and `compute_fft_magnitude` support custom pipelines and research extensions.

## 5. Notebooks and reproducibility

* **Legacy notebook**: `FFT and lattice.ipynb` provides an extensive narrative with markdown derivations and sliders. It remains untouched for continuity with prior explorations.
* **Demonstration notebook**: `lattice_fft_demo.ipynb` illustrates how to instantiate the dataclasses, sweep parameters, and visualise outputs using the packaged API.

Both notebooks rely exclusively on the package modules, ensuring that methodological changes propagate consistently.

## 6. Extending the project

The modular design supports:

* Parameter sweeps for lattice constants, disorder strengths, or temperature proxies.
* Integration with interactive dashboards (`ipywidgets`, Dash, or Streamlit) for teaching or remote experiments.
* Addition of new Bravais lattices or defect distributions by subclassing helper functions in `simulation.py`.
* Benchmarking FFT-based reconstructions against experimental diffraction patterns by replacing the simulated input image.

## 7. References

1. N. W. Ashcroft and N. D. Mermin, *Solid State Physics*, Holt-Saunders, 1976.
2. C. Kittel, *Introduction to Solid State Physics*, 8th ed., Wiley, 2005.
3. J. M. Cowley, *Diffraction Physics*, 3rd ed., North Holland, 1995.
4. R. N. Bracewell, *The Fourier Transform and Its Applications*, 3rd ed., McGraw-Hill, 1999.

## 8. License

MIT License — suitable for educational and research usage.
